#include "filearchiver.h"
using namespace std; 

const char* databaseStr = "tcp://127.0.0.1:3306";
const char* databaseUserName = "student72";
const char* databaseUserPassword = "KJmUZSWL";
const char* databaseSchema = "student72";
const char* noDB = "Sorry, but was unable to open database so operation failed";
const char* pf = "Failure when preparing statement";
const char* bf = "Failure when binding arguments";
const char* wf = "Failure when writing to database";
const char* of = "Failure when open file";
const char* curr_time="now()";
const char* gversion_num = "select curr_version from file_arc where file_name=?";
const char* findbid = "select block_id from file_version where file_arc_id=? and version_num=? order by id";
const char* gb_data = "select block_data from file_block where id=?";
const char* usrid = "hz740";
const char* removeDataVersion = "delete from file_version";
const char* removeDataArchiver = "delete from file_arc";
const char* removeDataBlock = "delete from file_block";
const char* removeDataComments = "delete from comments";

void filearchiver::deleteall()
{
    sql::PreparedStatement *pstmt = NULL;
    
    pstmt = dbcon->prepareStatement(removeDataComments);
    pstmt->executeUpdate();
    delete pstmt;
    pstmt = dbcon->prepareStatement(removeDataVersion);
    pstmt->executeUpdate();
    delete pstmt;
    pstmt = dbcon->prepareStatement(removeDataBlock);
    pstmt->executeUpdate();
    delete pstmt;
    pstmt = dbcon->prepareStatement(removeDataArchiver);
    pstmt->executeUpdate();
    delete pstmt;
}
/*
 *To compress files by using gzip
 * 
 * param name of file
 * return a bool to indicate whether success
 */
bool filearchiver::zip_file(string filename)
{
	string zip = "gzip -c \"";
        string command = zip + filename + "\" > \"" + filename +".gz\"";
        int rev = system(command.c_str());
        if (rev == 0)
            return true;
        else 
            return false;
}
/*
 *To uncompress files by using gzip
 * 
 * param name of file
    ;
 * return a bool to indicate whether success
 */
bool filearchiver::Unzip_file(string filename)
{
    string zip = "gzip -d \"";
    string command = zip + filename + "\"";
    filename = filename.substr(0, filename.rfind(".gz"));
    ifstream in(filename.c_str());
    if (in.good())
    {
        in.close();
        string cmd = "rm ";
        cmd += filename;
        system(cmd.c_str());

        int rev = system(command.c_str());
        if (rev == 0)
            return true;
        else 
            return false;

    }
    else
    {
        int rev = system(command.c_str());
        if (rev == 0)
            return true;
        else 
            return false;
    }
}
/*
 *A test function to check if I can pass a blob to the mysql datebase.
 * 
 * param the content of the blob with type of string
 * return no return value
 */
void filearchiver::insertblob(string a)
{
        if (invalid)
        throw (noDB);
    sql::PreparedStatement *pstmt = NULL;
    sql::ResultSet *rs = NULL;
    time_t b = this->get_curr_rawtime();
    pstmt = dbcon->prepareStatement("insert into file_block (`block_data`,`block_hash`,`create_date`) values (?, ?, FROM_UNIXTIME(?))");
    istringstream tmp(a);
    pstmt->setBlob(1,&tmp);
    pstmt->setInt(2,231);
    pstmt->setInt(3,b);
    pstmt->executeUpdate();
    delete pstmt;
}
/*
 * To get the last insert id which generated by auto increment
 * 
 * param no pass value
 * return the id of last insert record
 */
int filearchiver::get_last_insert()
{
    if (invalid)
        throw (noDB);
    const char* last_id="select LAST_INSERT_ID()";
    sql::PreparedStatement *pstmt = NULL;
    sql::ResultSet *rs = NULL;
    pstmt = dbcon->prepareStatement(last_id);
    int id = -1;
    rs = pstmt->executeQuery();
    if (rs->next()){
        id = rs->getInt(1);
    }
    delete rs;
    delete pstmt;
    return id;
}
/*
 *To get the current time which's unit is seconds 
 * 
 * param no pass value
 * return the time in second
 */
time_t filearchiver::get_curr_rawtime()
{
    time_t rawtime;
    struct tm* timeinfo;
    time(&rawtime);
    timeinfo = localtime(&rawtime);
    
    return (mktime(timeinfo));
}
/*
 *calculate the hash value of a filename by using its name and last modified time
 * 
 * param name of file
 * return the hash value which type is string
 */
string filearchiver::calhash(string filename){
    unsigned int hash;
    struct tm* clock;
    struct stat attrib;
    stat(filename.c_str(), &attrib);
    clock = localtime(&(attrib.st_mtime));
    hash = MurmurHash2(filename.c_str(),sizeof(filename.c_str()),mktime(clock));
    stringstream ss;
    ss << hash;
    string str = ss.str();
    return str;
}
/*
 *Get the length of a file
 * 
 * param name of file
 * return the length of specified file
 */
int filearchiver::callength(string filename){
    struct stat attrib;
    stat(filename.c_str(), &attrib);
    int length = attrib.st_size;
    
    return length;
}
/*
 * Default constructor of filearchiver object and it will try to connect to mysql database
 * 
 * param no pass value
 * return no return value
 */
filearchiver::filearchiver(){
    invalid = true;
    driver = get_driver_instance();
    try {
        dbcon = driver->connect(databaseStr,databaseUserName, databaseUserPassword);
    } catch (sql::SQLException &e) {cout<<e.what()<<endl;
        return;
    }
    dbcon->setSchema(databaseSchema);
    invalid = false;
}
/*
 * Default destructor of filearchiver object and it delete the connect and driver variables
 * 
 * param no pass value
 * return no return value
 */
filearchiver::~filearchiver(){
    if (!invalid)
    {
        this->close();
    }
}
/*
 * delete the connect and driver variables
 * 
 * param no pass value
 * return no return value
 */
void filearchiver::close(){
    if (!invalid){
        dbcon->close();
        delete dbcon;
    }
    invalid = true;
}
/*
 * check if the specified file has existed in the database
 * 
 * param name of file
 * return a bool value to indicate whether the file has existed
 */
bool filearchiver::exists(string file) throw (const char*) {
    if (invalid)
        throw (noDB);
    const char* countrecord = "select count(*) from file_arc where file_name=?";
    string filename = file.substr(file.find_last_of("/")+1);

    sql::PreparedStatement *pstmt = NULL;
    sql::ResultSet *rs = NULL;
    pstmt = dbcon->prepareStatement(countrecord);
    int count = 0;
    pstmt->setString(1,filename);
    rs = pstmt->executeQuery();
    if (rs->next()){
        count = rs->getInt(1);
    }
    delete rs;
    delete pstmt;
    return count == 1;
}
/*
 * use method of comparing hash to check if there is some difference berween
 * the input file and the data in the database
 * param name of file
 * return a bool value to indicate if there is any difference between current file
 * and the data in database
 */
bool filearchiver::differs(string file)throw (const char*){
    if (invalid)
        throw (noDB);
    string hash1,hash2;
 
    string filename = file.substr(file.find_last_of("/")+1);
    
    hash1 = this->calhash(file);
    hash2 = this->getHashOfLastSaved(filename);
    
    return hash1 != hash2;
}
/*
 * ask database the id of a filename
 * 
 * param name of file
 * return the id of specified file in database
 */
int filearchiver::getfileid(string filename) throw(const char*){
    if (invalid)
        throw (noDB);
    const char* findid = "select id from file_arc where file_name=?";
    int id;
    sql::PreparedStatement *pstmt = NULL;
    sql::ResultSet *rs = NULL;

    pstmt = dbcon->prepareStatement(findid);
    pstmt->setString(1,filename);
    rs = pstmt->executeQuery();
    if (rs->next()){
        id = rs->getInt(1);
    }
    delete rs;
    delete pstmt;

    return id;
}
/*
 * insert a file record into database which contains the overall file records, 
 * each lines data of file, user's comment and version information 
 * param name of file and user's comment
 * return no return value
 */
bool filearchiver::insertNew(string file, string comment)throw (const char*){
    if (invalid)
        throw (noDB);
    
    string filename = file.substr(file.find_last_of("/")+1);
    
    const char* filec = "insert into file_arc (`file_name`,`user_id`,`curr_version`,\
    `curr_hash`,`file_length`,`create_date`) values (?, ?, ?, ?, ?, FROM_UNIXTIME(?))";
    const char* comm = "insert into comments (`file_version_id`,`comments`,`create_date`) values (?, ?, FROM_UNIXTIME(?))";
    const char* version = "insert into file_version (`version_num`,`file_arc_id`,`block_id`,`file_length`,`create_date`,`file_hash`,`line_num`) values (?, ?, ? ,? ,FROM_UNIXTIME(?) ,? ,?)";
    const char* block = "insert into file_block (`block_data`,`block_hash`,`create_date`) values (?, ?, FROM_UNIXTIME(?))";
    
    string hash = this->calhash(file);
    int num_of_version = 0;
    int length = this->callength(file);
    time_t CurrTime = this->get_curr_rawtime();
    
    sql::PreparedStatement *pstmt = NULL;
    sql::ResultSet *rs = NULL;
    
    ifstream fi(file.c_str());
    if (!fi.good()){
        return false;
    }else{
        fi.close();
    }
    
    dbcon->setAutoCommit(false);
    
    pstmt = dbcon->prepareStatement(filec);
    pstmt->setString(1,filename);
    pstmt->setInt(2,1);
    pstmt->setInt(3,num_of_version);
    pstmt->setString(4,hash);
    pstmt->setInt(5,length);
    pstmt->setInt(6,CurrTime);
    pstmt->executeUpdate();
    delete pstmt;
    
    int id = this->get_last_insert();
    bool check = true;
    int vid,bid;
    string readfilename;
    
    vector<blob> content;
    if (this->zip_file(file))
    {    
        readfilename = file + ".gz";
        
        content = this->readfile(readfilename);
    }
    else
    {
        cout<<"can't compress file"<<endl;
        return false;
    }
    if (content.size())
    {
        for (int j=0;j<content.size();j++)
        {
            istringstream tmp(content[j].data);
            pstmt = dbcon->prepareStatement(block);
            pstmt->setBlob(1,&tmp);
            pstmt->setString(2,content[j].blob_hash);
            pstmt->setInt(3,CurrTime);
            pstmt->executeUpdate();
            delete pstmt;
         
            
            bid = this->get_last_insert();
            //bid = 1;
            pstmt = dbcon->prepareStatement(version);
            pstmt->setInt(1,num_of_version);
            pstmt->setInt(2,id);
            pstmt->setInt(3,bid);
            pstmt->setInt(4,length);
            pstmt->setInt(5,CurrTime);
            pstmt->setString(6,hash);
            pstmt->setInt(7,content[j].line_num);
            pstmt->executeUpdate();
            delete pstmt;
            
            if (content[j].line_num == 0&&check)
            {
                vid = this->get_last_insert();
                pstmt = dbcon->prepareStatement(comm);
                pstmt->setInt(1,vid);
                pstmt->setString(2,comment);
                pstmt->setInt(3,CurrTime);
                pstmt->executeUpdate();
                delete pstmt;
                check = false;
            }
        }
        content.clear();
        dbcon->commit();
        dbcon->setAutoCommit(true);
        
        string command = "rm " + readfilename;
        system(command.c_str());
        
    }
    else
        return false;
    return true;
}
/*
 * read specified file and put the content into a vector with type of blob
 * 160
 * param name of file
 * return a vector with type of blob
 */
vector<blob> filearchiver::readfile(string filename)
{
    fstream ins;
    ins.open(filename.c_str(),ios::in|ios::binary);
    vector<blob> content;
    if (ins.good())
    {
        int i = 0,bid;
        string temp;
        while (!ins.eof())
        {
            getline(ins,temp);
            int temphash = MurmurHash2(temp.c_str(),sizeof(temp.c_str()),7);
            blob tmp;
            tmp.line_num = i;
            if (!ins.eof())
                tmp.data = temp+"\n";
            else
                tmp.data = temp;
            stringstream ss;
            ss << temphash;
            string str = ss.str();
            tmp.blob_hash = str;
            content.push_back(tmp);
            i++;
        }
        ins.close();
    }
    
    return content;
};
/*
 * update the record of specified file (open called after the system find that 
 * the specified file has a new version)
 * param name of file and user's comment
 * return no return value
 */
bool filearchiver::update(string file,string comment) throw (const char*){
    if (invalid)
        throw (noDB);
    
    string filename = file.substr(file.find_last_of("/")+1);
    
    ifstream fi(file.c_str());
    if (!fi.good()){
        return false;
    }else{
        fi.close();
    }
    
    const char* upcurr_version = "update file_arc set curr_version=? where file_name=?";
    const char* upfile_hash = "update file_arc set curr_hash=? where file_name=?";
    const char* upfile_length = "update file_arc set file_length=? where file_name=?";
    const char* upfile_date = "update file_arc set create_date=FROM_UNIXTIME(?) where file_name=?";
    const char* comm = "insert into comments (`file_version_id`,`comments`,`create_date`) values (?, ?, FROM_UNIXTIME(?))";
    const char* version = "insert into file_version (`version_num`,`file_arc_id`,`block_id`,`file_length`,`create_date`,`file_hash`,`line_num`) values (?, ?, ? ,? ,FROM_UNIXTIME(?) ,? ,?)";
    const char* block = "insert into file_block (`block_data`,`block_hash`,`create_date`) values (?, ?, FROM_UNIXTIME(?))";
    
    sql::PreparedStatement *pstmt = NULL;
    sql::ResultSet *rs = NULL;
    
    int num_of_version = this->getCurrentVersionNumber(filename);

    num_of_version++;
    int prev = num_of_version-1;
    string hash = this->calhash(file);
    int id = this->getfileid(filename);
    int length = this->callength(file);
    time_t CurrTime = this->get_curr_rawtime();


    pstmt = dbcon->prepareStatement(upcurr_version);
    pstmt->setInt(1,num_of_version);
    pstmt->setString(2,filename);
    pstmt->executeUpdate();
    delete pstmt;
    
    pstmt = dbcon->prepareStatement(upfile_hash);
    pstmt->setString(1,hash);
    pstmt->setString(2,filename);
    pstmt->executeUpdate();
    delete pstmt;
    
    pstmt = dbcon->prepareStatement(upfile_length);
    pstmt->setInt(1,length);
    pstmt->setString(2,filename);
    pstmt->executeUpdate();
    delete pstmt;
    
    pstmt = dbcon->prepareStatement(upfile_date);
    pstmt->setInt(1,CurrTime);
    pstmt->setString(2,filename);
    pstmt->executeUpdate();
    delete pstmt;
    bool check = true;
    
    string readfilename;
    const char* getcontent = "select b.block_hash, v.line_num, b.id from file_block b ,file_version v, file_arc a where b.id = v.block_id and v.file_arc_id = a.id and a.file_name=? and v.version_num=? order by v.line_num";
    vector<blob> content;
    if (this->zip_file(file))
    {    
        readfilename = file + ".gz";
        content = this->readfile(readfilename);        
    }
    else
    {
        cout<<"can't compress file"<<endl;
        return false;
    }
    dbcon->setAutoCommit(false);
    
    if (content.size())
    {
        int bid,vid;
        sql::PreparedStatement *pstmt2 = NULL;
        sql::ResultSet *rs2 = NULL;
        pstmt2 = dbcon->prepareStatement(getcontent);
        pstmt2->setString(1,filename);
        pstmt2->setInt(2,prev);
        rs2 = pstmt2->executeQuery();
        string hash2;
        
        while (rs2->next())
        {
            hash2 = rs2->getString(1);
            for (int j=0;j<content.size();j++)
            {
                
                if (content[j].blob_hash == hash2)
                {
                    bid = rs2->getInt(3);
                    pstmt = dbcon->prepareStatement(version);
                    pstmt->setInt(1,num_of_version);
                    pstmt->setInt(2,id);
                    pstmt->setInt(3,bid);
                    pstmt->setInt(4,length);
                    pstmt->setInt(5,CurrTime);
                    pstmt->setString(6,hash);
                    pstmt->setInt(7,content[j].line_num);
                    pstmt->executeUpdate();
                    delete pstmt;
                    
                    if (content[j].line_num==0&&check)
                    {
                        vid = this->get_last_insert();
                        pstmt = dbcon->prepareStatement(comm);
                        pstmt->setInt(1,vid);
                        pstmt->setString(2,comment);
                        pstmt->setInt(3,CurrTime);
                        pstmt->executeUpdate();
                        delete pstmt;
                        check = false;
                    }
                content.erase(content.begin()+j);
                }
            }
        }

        delete rs2;
        delete pstmt2;
        
        for (int j=0;j<content.size();j++)
        {
            istringstream tmp(content[j].data);
            pstmt = dbcon->prepareStatement(block);
            pstmt->setBlob(1,&tmp);
            pstmt->setString(2,content[j].blob_hash);
            pstmt->setInt(3,CurrTime);
            pstmt->executeUpdate();
            delete pstmt;
            
            bid = this->get_last_insert();
            
            pstmt = dbcon->prepareStatement(version);
            pstmt->setInt(1,num_of_version);
            pstmt->setInt(2,id);
            pstmt->setInt(3,bid);
            pstmt->setInt(4,length);
            pstmt->setInt(5,CurrTime);
            pstmt->setString(6,hash);
            pstmt->setInt(7,content[j].line_num);
            pstmt->executeUpdate();
            delete pstmt;
            
            if (content[j].line_num == 0&&check)
            {
                vid = this->get_last_insert();
                pstmt = dbcon->prepareStatement(comm);
                pstmt->setInt(1,vid);
                pstmt->setString(2,comment);
                pstmt->setInt(3,CurrTime);
                pstmt->executeUpdate();
                delete pstmt;
                check = false;
            }
        }
        content.clear();
        dbcon->commit();
        dbcon->setAutoCommit(true);
        
        string command = "rm " + readfilename;
        system(command.c_str());
    }
    else 
        return false;
    return true;
}
/*
 * retrieve a specified file with a specified version to a given file from database
 *  
 * param number of version, name of file and the file which data will be retrieved to
 * return no return value
 */
bool filearchiver::retrieveVersion(int versionnum, string file, string retrito)throw (const char*){
    if (invalid)
        throw (noDB);
    
    string filename = file.substr(file.find_last_of("/")+1);
    retrito += ".gz";
    
    const char* findbhash = "select b.id, block_hash, v.line_num from file_block b, file_version v, file_arc a where b.id = v.block_id and v.file_arc_id = a.id and a.file_name=? and v.version_num=? order by v.line_num";
    int bid;
    string hash;
    string data;
    sql::PreparedStatement *pstmt = NULL;
    sql::ResultSet *rs = NULL;
    
    sql::PreparedStatement *pstmt2 = NULL;
    sql::ResultSet *rs2 = NULL;
    pstmt2 = dbcon->prepareStatement(findbhash);
    pstmt2->setString(1,filename);
    pstmt2->setInt(2,versionnum);
    rs2 = pstmt2->executeQuery();  
    
    fstream outs;
    outs.open(retrito.c_str(),ios::out|ios::binary);

    if (outs.good())
    {
        while (rs2->next())
        {
            bid = rs2->getInt(1);
            hash = rs2->getString(2);
            
            pstmt = dbcon->prepareStatement(gb_data);
            pstmt->setInt(1,bid);
            rs = pstmt->executeQuery();
            if (rs->next()){
                data = rs->getString(1);
            }
            delete rs;
            delete pstmt;
        
            outs<<data;
        }
        outs.close();
        delete rs2;
        delete pstmt2;
    }
    else 
        return false;
    
    if (this->Unzip_file(retrito))
        return true;
    else
        cout<<"can't decompress file"<<endl;
    return false;
}
/*
 * get the newest version of a specified file
 * 
 * param name of file
 * return the newest version number of the file
 */
int filearchiver::getCurrentVersionNumber(string filename)throw (const char*){
    if (invalid)
        throw (noDB);
    int cv;   
    const char* gversion_num = "select curr_version from file_arc where file_name=?";
    sql::PreparedStatement *pstmt = NULL;
    sql::ResultSet *rs = NULL;
    
    pstmt = dbcon->prepareStatement(gversion_num);
    pstmt->setString(1,filename);
    rs = pstmt->executeQuery();
    if (rs->next()){
        cv = rs->getInt(1);
    }
    delete rs;
    delete pstmt;

    return cv;
}
/*
 * get the hash value of the newest version of a specified file
 * 
 * param name of file
 * return the hash value of the newest version
 */
string filearchiver::getHashOfLastSaved(string filename)throw (const char*){
    if (invalid)
        throw (noDB);
    string hash;
    sql::PreparedStatement *pstmt = NULL;
    sql::ResultSet *rs = NULL;
    const char* ghash = "select curr_hash from file_arc where file_name=?";
    pstmt = dbcon->prepareStatement(ghash);
    pstmt->setString(1,filename.substr(filename.find_last_of("/")+1));
    rs = pstmt->executeQuery();
    if (rs->next()){
        hash = rs->getString(1);
    }
    delete rs;
    delete pstmt;
    
    return hash;
}
/*
 * get the version id of a version
 * 
 * param name of file and number of version
 * return id of the version
 */
int filearchiver::getVersionID(string filename,int versionnum){
    if (invalid)
        throw (noDB);
    int vid;
    int id = this->getfileid(filename);
    sql::PreparedStatement *pstmt = NULL;
    sql::ResultSet *rs = NULL;
    const char* gversion_id = "select id, line_num from file_version where version_num=? and file_arc_id=(select id from file_arc where file_name=?) order by line_num ";
    pstmt = dbcon->prepareStatement(gversion_id);
    pstmt->setInt(1,versionnum);
    pstmt->setString(2,filename.substr(filename.find_last_of("/")+1));
    rs = pstmt->executeQuery();
    if (rs->next()){
        vid = rs->getInt(1);
    }
    delete rs;
    delete pstmt;
    return vid;
}
/*
 * get the comment of one of version of a specified file
 * 
 * param name of file and number of version
 * return comment of this version
 */
string filearchiver::getComment(string file, int versionnum)throw (const char*){
    if (invalid)
        throw (noDB);
    
    string filename = file.substr(file.find_last_of("/")+1);
    
    const char* gcomment = "select comments from comments where file_version_id=?";
    int vid = this->getVersionID(filename,versionnum);
    string recomment;
    sql::PreparedStatement *pstmt = NULL;
    sql::ResultSet *rs = NULL;
    
    pstmt = dbcon->prepareStatement(gcomment);
    pstmt->setInt(1,vid);
    rs = pstmt->executeQuery();
    if (rs->next()){
        recomment = rs->getString(1);
    }
    delete rs;
    delete pstmt;

    return recomment;
}
/*
 * get the length and create date of all version 
 * 
 * param name of file
 * return vector with type of versionRec
 */
vector<versionRec> filearchiver::getVersionInfo(string filename)throw (const char*){
    if (invalid)
        throw (noDB);

    vector<versionRec> rev ;
    const char* gversioninfo = "select version_num, file_length, create_date from file_version  where version_num<>-1 and line_num=0 and file_arc_id=(select id from file_arc where file_name=?) order by 1";
    versionRec temp;
    int file_length, version_num;
    string date;
    
    sql::PreparedStatement *pstmt = NULL;
    sql::ResultSet *rs = NULL;    
    pstmt = dbcon->prepareStatement(gversioninfo);
    pstmt->setString(1,filename.substr(filename.find_last_of("/")+1));
    rs = pstmt->executeQuery();
    
    while(rs->next())
    {
        version_num =  rs->getInt(1);
        file_length = rs->getInt(2);
        date = rs->getString(3);
        temp.setlength(file_length);
        temp.setdate(date);
        temp.setversionnum(version_num);
        rev.push_back(temp);    
    }
    delete rs;
    delete pstmt;

    return rev;
}
/*
 * choose a version and set it as original version
 * 
 * param name of file ,  number of version and user's comment
 * return no return value
 */
bool filearchiver::setReference(string file, int versionnum, string comment)throw (const char*){
    if (invalid)
        throw (noDB);
    
    string filename = file.substr(file.find_last_of("/")+1);
    
    const char* upcurr_version = "update file_arc set curr_version=? where file_name=?";
    const char* upfile_hash = "update file_arc set curr_hash=? where file_name=?";
    const char* upfile_length = "update file_arc set file_length=? where file_name=?";
    const char* upfile_date = "update file_arc set create_date=FROM_UNIXTIME(?) where file_name=?";
    const char* up_comments = "update comments set comments=? where file_version_id=?";
    sql::PreparedStatement *pstmt = NULL;
    sql::ResultSet *rs = NULL;
    int total_version = this->getCurrentVersionNumber(filename);
    
    if (versionnum <= 0 || versionnum > total_version){
        return false;
    }
        

    int vid = this->getVersionID(filename,versionnum);
    
    unsigned int hash;
    int length;
    time_t CurrTime;
    const char* g_version_time = "select file_hash,file_length,TIME_TO_SEC(create_date) from file_version where id=?";
    pstmt = dbcon->prepareStatement(g_version_time);
    pstmt->setInt(1,vid);
    rs = pstmt->executeQuery();
    if (rs->next()){
        hash = rs->getInt(1);
        length = rs->getInt(2);
        CurrTime = rs->getInt(3);
    }
    else
        return false;
    delete rs;
    delete pstmt;
    
    pstmt = dbcon->prepareStatement(upcurr_version);
    pstmt->setInt(1,total_version - versionnum);
    pstmt->setString(2,filename);
    pstmt->executeUpdate();
    delete pstmt;
    
    pstmt = dbcon->prepareStatement(upfile_hash);
    pstmt->setInt(1,hash);
    pstmt->setString(2,filename);
    pstmt->executeUpdate();
    delete pstmt;
    
    pstmt = dbcon->prepareStatement(upfile_length);
    pstmt->setInt(1,length);
    pstmt->setString(2,filename);
    pstmt->executeUpdate();
    delete pstmt;
    
    pstmt = dbcon->prepareStatement(upfile_date);
    pstmt->setInt(1,CurrTime);
    pstmt->setString(2,filename);
    pstmt->executeUpdate();
    delete pstmt;
    
    pstmt = dbcon->prepareStatement(up_comments);
    pstmt->setString(1,comment);
    pstmt->setInt(2,vid);
    pstmt->executeUpdate();
    delete pstmt;
    
    const char* update_all = "update file_version set version_num=? where file_arc_id=(select id from file_arc where file_name=?) and version_num=?";

    dbcon->setAutoCommit(false);
    
    for (int i=0;i<versionnum;i++)
    {
        
        pstmt = dbcon->prepareStatement(update_all);
        pstmt->setInt(1,-1);
        pstmt->setString(2,filename);
        pstmt->setInt(3,i);
        pstmt->executeUpdate();
        delete pstmt;
    }
    
    for (int i=versionnum;i<=total_version;i++)
    {
        
        pstmt = dbcon->prepareStatement(update_all);
        pstmt->setInt(1,i-versionnum);
        pstmt->setString(2,filename);
        pstmt->setInt(3,i);
        pstmt->executeUpdate();
        delete pstmt;
    }
    
    dbcon->commit();
    dbcon->setAutoCommit(true);
    return true;
}